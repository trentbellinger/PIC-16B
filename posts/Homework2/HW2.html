<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.540">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Trent Bellinger">
<meta name="dcterms.date" content="2024-02-05">

<title>PIC 16B Website - Trent Bellinger - Web Scraper for Movie and TV Show Reccomendations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">PIC 16B Website - Trent Bellinger</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Web Scraper for Movie and TV Show Reccomendations</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">week 0</div>
                <div class="quarto-category">example</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Trent Bellinger </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 5, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="this-blog-post-will-outline-my-completion-of-pic-16b-homework-2.-i-will-describe-my-creation-of-a-web-scraper-that-answers-the-following-question-what-movie-or-tv-shows-share-actors-with-your-favorite-movie-or-show-i-break-the-process-into-4-simple-steps." class="level2">
<h2 class="anchored" data-anchor-id="this-blog-post-will-outline-my-completion-of-pic-16b-homework-2.-i-will-describe-my-creation-of-a-web-scraper-that-answers-the-following-question-what-movie-or-tv-shows-share-actors-with-your-favorite-movie-or-show-i-break-the-process-into-4-simple-steps.">This blog post will outline my completion of PIC 16B homework 2. I will describe my creation of a web scraper that answers the following question: What movie or TV shows share actors with your favorite movie or show? I break the process into 4 simple steps.</h2>
</section>
<section id="step-1-initializing-the-project" class="level1">
<h1>Step 1: Initializing the Project</h1>
<ul>
<li>We first go into the PIC16B-24W environment by running the following line in the terminal:</li>
</ul>
<p><strong>conda activate PIC16B-24W</strong></p>
<ul>
<li>In order to start the scrapy project, we first set the working directory into the folder that we want to work in, which for me was my PIC 16B Homework 2 folder. To do this, run this in the terminal:</li>
</ul>
<p><strong>cd your_desired_working_directory</strong></p>
<p><strong>cd /Users/trentbellinger/Desktop/PIC16B/Homework/Homework2 (for me)</strong></p>
<ul>
<li>We then start the scrapy project, named TMDB_scraper. This will create a TMDB_scraper folder in the current working directory established above. To do this, run this in the terminal:</li>
</ul>
<p><strong>scrapy startproject TMDB_scraper</strong></p>
<ul>
<li>Now change the directory to be the TMDB_scraper folder by running this in the terminal:</li>
</ul>
<p><strong>cd TMDB_scraper</strong></p>
<ul>
<li>After the project is set up, navigate to the file settings.py (TMDB_scraper -&gt; TMDB_scraper -&gt; settings.py). Add the following line to the file (this ensures we do not load in too much data in our preliminary testing of the scraper).</li>
</ul>
<p><strong>CLOSESPIDER_PAGECOUNT = 20</strong></p>
<ul>
<li>We now have to set up a user agent to grant the spider access to the TMDB site, which we do by adding the following line to the settings.py file (without this line, the scraper will run into 403 errors and will not be able to run).</li>
</ul>
<p><strong>USER_AGENT = ‘Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148’</strong></p>
<ul>
<li>This concludes the initialization process of the scraper.</li>
</ul>
</section>
<section id="step-2-writing-the-tmdbspider-class" class="level1">
<h1>Step 2: Writing the TmdbSpider Class:</h1>
<ul>
<li>The goal of this class is to create a spider that scrapes a movie website from TMDB and finds other movies and TV shows that have similar actors to the selected movie.</li>
<li>To write this class, navigate to the spiders folder (TMDB_scpraper -&gt; TMDB_scraper -&gt; spiders) and create a file called tmdb_spider.py inside of it. All of the following code should be written in this file.</li>
</ul>
<section id="step-2a-class-initialization" class="level2">
<h2 class="anchored" data-anchor-id="step-2a-class-initialization">Step 2(a): Class Initialization</h2>
<ul>
<li>The first code that we write in this file is the class initialization, which is shown below.</li>
</ul>
<div id="bd341045" class="cell" data-execution_count="88">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scrapy</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TmdbSpider(scrapy.Spider):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">    This class is for a spider that scrapes a movie website from TMDB and finds other </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">    movies and TV shows that have similar actors to the selected movie.</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    name <span class="op">=</span> <span class="st">'tmdb_spider'</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, subdir<span class="op">=</span><span class="va">None</span>, <span class="op">*</span>args, <span class="op">**</span>kwargs):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.start_urls <span class="op">=</span> [<span class="ss">f"https://www.themoviedb.org/movie/</span><span class="sc">{</span>subdir<span class="sc">}</span><span class="ss">/"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>As we can see, the class is initialized with global variable name=‘tmdb_spider’. The variables subdir, *args, and **kwargs are passed into the initialization of the class. The subdir instance variable is the subdirectory of the movie that we want to scrape data from on the TMDB website. We then initialize the instance variable start_urls which contains the url of the movie that we want to scrape data from.</li>
</ul>
</section>
<section id="step-2b-the-parse-method" class="level2">
<h2 class="anchored" data-anchor-id="step-2b-the-parse-method">Step 2(b): The parse() Method</h2>
<ul>
<li>We now move on to creating the parsing methods for the scraper.</li>
<li>The first of these methods is the parse method. This method assumes that we are on the selected movie’s TMDB page and navigates the spider to the Full Cast &amp; Crew page. Once on this page, we call the parse_full_credits method, which will be defined later.</li>
<li>The code for the parse method is below.</li>
</ul>
<div id="314528fe" class="cell" data-execution_count="89">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse(<span class="va">self</span>, response):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Yields the cast page of the selected movie and calls the parse_full_credits </span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    method.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span>  </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># go the the cast page of the selected movie and call the parse_full_credits method</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    cast_url <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>start_urls[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">cast"</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> scrapy.Request(cast_url, callback <span class="op">=</span> <span class="va">self</span>.parse_full_credits)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="step-2c-the-parse_full_credits-method" class="level2">
<h2 class="anchored" data-anchor-id="step-2c-the-parse_full_credits-method">Step 2(c): The parse_full_credits() Method</h2>
<ul>
<li>The parse_full_credits method assumes that we are on the selected movie’s Full Cast &amp; Crew page on TMDB. It yields a scrapy request for each actor listed on the page (crew members are excluded). When each actor’s request is yielded, we call the parse_actor_page method, which will be defined later.</li>
<li>To accomplish this, we must first find a list of all the actor’s URLs on the page and then loop through this list and yield the URL to each actor’s page on TMDB.</li>
<li>The code for this method is below.</li>
</ul>
<div id="1ffde679" class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_full_credits(<span class="va">self</span>, response):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Starts at the cast page for the selected movie and yields requests for the </span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">    TMDB page of each actor on the cast page (excluding crew members), calling </span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">    the parse_actor_page method.</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># get all the links for the actors on the cast page of the movie</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    actors_css <span class="op">=</span> <span class="st">'ol.people.credits:not(.crew) li div.info a::attr(href)'</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    actors <span class="op">=</span> response.css(actors_css).extract()</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># loop through the actor links on the page, excluding crew members</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> actor_link <span class="kw">in</span> actors:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># join the actor url with the response url</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        url <span class="op">=</span> response.urljoin(actor_link) </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># create a request using the above url and call the parse_actor_page method</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> scrapy.Request(url, callback <span class="op">=</span> <span class="va">self</span>.parse_actor_page)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="step-2d-the-parse_actor_page-method" class="level2">
<h2 class="anchored" data-anchor-id="step-2d-the-parse_actor_page-method">Step 2(d): The parse_actor_page() Method</h2>
<ul>
<li>The parse_actor_page method assumes that we are on the TMDB page for an actor. The method yields a dictionary of the form {“actor” : actor_name, “movie_or_TV_name” : movie_or_TV_name} for each acting role that the actor has had in their career (non-acting roles are excluded).</li>
<li>To accomplish this, we first find the actor’s name on the actor’s TMDB page. We then need to loop through the different credits tables on the page and find the one that contains only the acting roles. We then create a selector for this table, loop through the entries of the table, and yield a dictionary of the actor’s name and the role for each role in the table.</li>
<li>The code for this method is below.</li>
</ul>
<div id="88ddb23b" class="cell" data-execution_count="90">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_actor_page(<span class="va">self</span>, response):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Starts on the TMDB page of an actor and yields a dictionary containing the </span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">    actor's name and the movie or TV show for each of their acting roles.</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># get the actor's name from their page</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    actor_name <span class="op">=</span> response.css(<span class="st">'h2.title a::text'</span>).get().strip()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># loop through the types of credit lists on the page</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> item <span class="kw">in</span> response.css(<span class="st">'div.credits_list h3'</span>):</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># if the credit list is for acting</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">'Acting'</span> <span class="kw">in</span> item.xpath(<span class="st">'./text()'</span>).get():</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="co"># get the table of acting roles</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            acting_table <span class="op">=</span> item.xpath(<span class="st">'following-sibling::table[1]'</span>).get()</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create a selector for the table of acting roles</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    acting_selector <span class="op">=</span> scrapy.Selector(text <span class="op">=</span> acting_table)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># loop through the table of acting roles</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> acting <span class="kw">in</span> acting_selector.css(<span class="st">'table.credit_group tr'</span>):</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># get the movie or TV show name from the current acting role</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        movie_or_TV_name <span class="op">=</span> acting.css(<span class="st">'td.role a.tooltip bdi::text'</span>).get().strip()</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> {<span class="st">"actor"</span>: actor_name, <span class="st">"movie_or_TV_name"</span>: movie_or_TV_name}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>We now have a fully functional web spraper that yields various dictionaries for each acting role of each actor in the selected movie.</li>
</ul>
<p><strong>IMPORTANT NOTE: the methods parse, parse_full_credits, and parse_actor_page are defined within the TmdbSpider class initialized in part 2(a)</strong></p>
</section>
</section>
<section id="step-3-testing-the-scraper" class="level1">
<h1>Step 3: Testing the Scraper</h1>
<ul>
<li>We will now show two different tests that were performed on two different movies using the scraper.</li>
<li>Before doing these tests, we must comment out the CLOSESPIDER_PAGECOUNT = 20 line in the settings.py file to allow the whole website to be scraped for each of the movies.</li>
</ul>
<section id="test-1-harry-potter-and-the-philosophers-stone" class="level2">
<h2 class="anchored" data-anchor-id="test-1-harry-potter-and-the-philosophers-stone">Test 1: Harry Potter and the Philosopher’s Stone</h2>
<ul>
<li>The goal of this test is to create a .csv file that contains all of the {actor:role} pairs that are yielded by our TmdbSpider class for the movie Harry Potter and the Philosopher’s Stone.</li>
<li>This was accomplished by running the follwing line in the terminal, while still in the same TMDB_scraper directory as in step 1.</li>
</ul>
<p><strong>scrapy crawl tmdb_spider -o results1.csv -a subdir=671-harry-potter-and-the-philosopher-s-stone</strong></p>
<ul>
<li>After this line is run, a results1.csv file will be created in the TMDB_scraper folder.</li>
<li>We need to make sure this file is of the correct format, which is done below.</li>
</ul>
<div id="9172c6de" class="cell" data-execution_count="91">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>results1 <span class="op">=</span> pd.read_csv(<span class="st">"results1.csv"</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>results1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="91">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">actor</th>
<th data-quarto-table-cell-role="th">movie_or_TV_name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>Daniel Radcliffe</td>
<td>Have I Got a Bit More News for You</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>Daniel Radcliffe</td>
<td>David Holmes: The Boy Who Lived</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>Daniel Radcliffe</td>
<td>100 Years of Warner Bros.</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>Daniel Radcliffe</td>
<td>Mulligan</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>Daniel Radcliffe</td>
<td>Digman!</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2952</td>
<td>James Phelps</td>
<td>Kingdom</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2953</td>
<td>James Phelps</td>
<td>Harry Potter and the Goblet of Fire</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2954</td>
<td>James Phelps</td>
<td>Harry Potter and the Prisoner of Azkaban</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2955</td>
<td>James Phelps</td>
<td>Harry Potter and the Chamber of Secrets</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2956</td>
<td>James Phelps</td>
<td>Harry Potter and the Philosopher's Stone</td>
</tr>
</tbody>
</table>

<p>2957 rows × 2 columns</p>
</div>
</div>
</div>
<ul>
<li>We can se that the results1.csv file is in the correct format, with one column for actor name and one column for the movie or TV show they acted in. There are 2957 observations.</li>
<li>We will now check is our dataset contains only the actors in the movie (i.e.&nbsp;it excludes the crew members).</li>
</ul>
<div id="e4b6174d" class="cell" data-execution_count="92">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>results1[<span class="st">'actor'</span>].nunique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="92">
<pre><code>63</code></pre>
</div>
</div>
<ul>
<li>Here, we see that there are 63 total actors in the dataset. When viewing the TMDB webpage for the movie, there are exactly 63 actors in the movie, so our scraper successfully weeded out the crew members and only included the actors.</li>
<li>We will now check that each actor is only in the dataset for their acting roles (not their roles in production, directing, etc.). We use Daniel Radcliffe as our test.</li>
</ul>
<div id="407fb020" class="cell" data-execution_count="93">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>results1.groupby(<span class="st">'actor'</span>).size()[<span class="st">'Daniel Radcliffe'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="93">
<pre><code>97</code></pre>
</div>
</div>
<ul>
<li>We can see here that the actor Daniel Radcliffe is found 97 times in the dataset, meaning that he should have 97 acting roles in his career. When viewing the TMD webpage for Daniel Radcliffe, he does in fact have exactly 97 acting roles, so our scraper has successfully weeded out non-acting roles for each actor.</li>
<li>Our scraper has worked as expected, so our test is successul.</li>
</ul>
</section>
<section id="test-2-good-will-hunting" class="level2">
<h2 class="anchored" data-anchor-id="test-2-good-will-hunting">Test 2: Good Will Hunting</h2>
<ul>
<li>We will now test the scraper on my favorite movie, Good Will Hunting.</li>
<li>The goal of this test is to create a .csv file that contains all of the {actor:role} pairs that are yielded by our TmdbSpider class for the movie Good Will Hunting.</li>
<li>This was accomplished by running the follwing line in the terminal, while still in the same TMDB_scraper directory as in step 1.</li>
</ul>
<p><strong>scrapy crawl tmdb_spider -o results2.csv -a subdir=489-good-will-hunting</strong></p>
<ul>
<li>After this line is run, a results2.csv file is created in the TMDB_scraper folder.</li>
<li>We just need to make sure this file is of the correct format, which is done below.</li>
</ul>
<div id="97a9e8ee" class="cell" data-execution_count="94">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>results2 <span class="op">=</span> pd.read_csv(<span class="st">"results2.csv"</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>results2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="94">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">actor</th>
<th data-quarto-table-cell-role="th">movie_or_TV_name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>Christian Harmony</td>
<td>The Doorway</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>Christian Harmony</td>
<td>Sex and the City</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>Christian Harmony</td>
<td>Good Will Hunting</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>Stephen L'Heureux</td>
<td>Good Will Hunting</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>Stephen L'Heureux</td>
<td>Scent of a Woman</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1500</td>
<td>Casey Affleck</td>
<td>LIVE with Kelly and Mark</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1501</td>
<td>Casey Affleck</td>
<td>Lemon Sky</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1502</td>
<td>Casey Affleck</td>
<td>Saturday Night Live</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1503</td>
<td>Matt Mercier</td>
<td>Good Will Hunting</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1504</td>
<td>Rachel Majorowski</td>
<td>Good Will Hunting</td>
</tr>
</tbody>
</table>

<p>1505 rows × 2 columns</p>
</div>
</div>
</div>
<ul>
<li>We can se that the results2.csv file is in the correct format, with one column for actor name and one column for the movie or TV show they acted in. There are 1505 observations.</li>
<li>We will now check is our dataset contains only the actors in the movie (i.e it excludes the crew members).</li>
</ul>
<div id="7c4659b7" class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>results2[<span class="st">'actor'</span>].nunique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="70">
<pre><code>49</code></pre>
</div>
</div>
<ul>
<li>Here, we see that there are 49 total actors in the dataset. When viewing the TMDB webpage for the movie, there are exactly 49 actors in the movie, so our scraper successfully weeded out the crew members and only included the actors.</li>
<li>We will now check that each actor is only in the dataset for their acting roles, and not their roles in production, directing, etc. We use Matt Damon as our test.</li>
</ul>
<div id="cddce06b" class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>results2.groupby(<span class="st">'actor'</span>).size()[<span class="st">'Matt Damon'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="71">
<pre><code>163</code></pre>
</div>
</div>
<ul>
<li>We can see here that the actor Matt Damon is found 163 times in the dataset, meaning that he should have 163 acting roles in his career. When viewing the TMD webpage for Matt Damon, he does in fact have exactly 163 acting roles, so our scraper has successfully weeded out non-acting roles for each actor.</li>
<li>Our scraper has worked as expected, so our test is successul.</li>
</ul>
</section>
</section>
<section id="step-4-making-recommendations" class="level1">
<h1>Step 4: Making Recommendations</h1>
<ul>
<li>We will now make recommendations for other TV shows and movies. This will be done by creating a Pandas dataframe to show the movies and TV shows that share the most actors with the selected movie or TV show.</li>
<li>We want to use the dataframes that our scraper creates (like the ones above) to create dataframe with two columns “movie or TV name” and “number of shared actors”. The creation of this dataframe is created in a function that is outlined below.</li>
</ul>
<div id="8cdf5f88" class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> recommend_dataframe(df):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns a Pandas dataframe with two columns "movie or TV name" and "number of </span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">    shared actors" when a dataframe created by our scraper is inputted.</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    df_grouped <span class="op">=</span> df.groupby(<span class="st">"movie_or_TV_name"</span>).size()</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame({<span class="st">"movie or TV name"</span>:df_grouped.index, </span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>                         <span class="st">"number of shared actors"</span>:df_grouped.values})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>We will also create a barplot to show the movie and TV show recommendations that we should make for each movie. A function to create this plot is outlined below.</li>
</ul>
<div id="809e8e41" class="cell" data-execution_count="95">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.gridspec <span class="im">import</span> GridSpec</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> recommend_barplot(df, movie, min_num_shared_actors):</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns a matplotlib.pyplot barplot of the number of shared actors in each</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co">    movie with at least min_num_shared_actors of the selected movie using the </span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="co">    data found in df.</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Arguments:</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="co">        df (Pandas dataframe): a dataframe with columns "movie or TV name" and </span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="co">                               "number of shared actors"</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="co">        movie (str): a string of the movie we are using</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="co">        min_num_shared_actors (int): an integer representing the minimum number of </span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="co">                                     shared actors a movie or TV show must have to be </span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="co">                                     presented in the plot</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="co">                                     </span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="co">        A matplotlib.pyplot barplot with the bar height the number of shared actors and</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="co">        the x-axis being the movies we are considering.</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># subset the dataset by movies or tv shows having over min_num_shared_actors</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    df_plot <span class="op">=</span> df.loc[df[<span class="st">"number of shared actors"</span>] <span class="op">&gt;</span> min_num_shared_actors,:]</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># take out the current movie observation from the dataset</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    df_plot <span class="op">=</span> df_plot.loc[df_plot[<span class="st">"movie or TV name"</span>] <span class="op">!=</span> movie,:]</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create a bar plot showing the most similar movies and TV shows</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    plt.bar(df_plot[<span class="st">"movie or TV name"</span>], df_plot[<span class="st">"number of shared actors"</span>])</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>    plt.xticks(rotation <span class="op">=</span> <span class="dv">90</span>)</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Number of Shared Actors"</span>)</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Movie or TV Show Name"</span>)</span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f"Similar Movies and TV Shows to </span><span class="sc">{</span>movie<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="recommendations-for-harry-potter-and-the-philosophers-stone" class="level2">
<h2 class="anchored" data-anchor-id="recommendations-for-harry-potter-and-the-philosophers-stone">Recommendations for Harry Potter and the Philosopher’s Stone</h2>
<ul>
<li>Using the results1.csv dataframe imported above, we create a dataframe with two columns “movie or TV name” and “number of shared actors” using the recommend_dataframe() function.</li>
</ul>
<div id="f11f7355" class="cell" data-execution_count="96">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>recommendations1 <span class="op">=</span> recommend_dataframe(results1)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>recommendations1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="96">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">movie or TV name</th>
<th data-quarto-table-cell-role="th">number of shared actors</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>(K)nox: The Rob Knox Story</td>
<td>4</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>10 Days to War</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>10 Rillington Place</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>100 Years of Warner Bros.</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>13Hrs</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2270</td>
<td>Your Christmas or Mine 2</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2271</td>
<td>Your Christmas or Mine?</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2272</td>
<td>Your Ticket Is No Longer Valid</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2273</td>
<td>Yub-Nub! The Forgotten Ewok Adventures</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2274</td>
<td>Zastrozzi: A Romance</td>
<td>1</td>
</tr>
</tbody>
</table>

<p>2275 rows × 2 columns</p>
</div>
</div>
</div>
<ul>
<li>We can see that our function works in creating the dataframe with the two desired columns.</li>
<li>We will now sort by movies or tv shows that have more than 5 shared actors with Harry Potter and the Philosopher’s Stone.</li>
</ul>
<div id="2e02a4ca" class="cell" data-execution_count="97">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>recommendations1.loc[recommendations1[<span class="st">"number of shared actors"</span>] <span class="op">&gt;</span> <span class="dv">5</span>,:]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="97">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">movie or TV name</th>
<th data-quarto-table-cell-role="th">number of shared actors</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">116</td>
<td>An Audience with...</td>
<td>6</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">382</td>
<td>Creating the World of Harry Potter</td>
<td>36</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">415</td>
<td>David Holmes: The Boy Who Lived</td>
<td>6</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">455</td>
<td>Doctor Who</td>
<td>14</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">693</td>
<td>Harry Potter 20th Anniversary: Return to Hogwarts</td>
<td>11</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">694</td>
<td>Harry Potter and the Chamber of Secrets</td>
<td>37</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">695</td>
<td>Harry Potter and the Deathly Hallows: Part 1</td>
<td>20</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">696</td>
<td>Harry Potter and the Deathly Hallows: Part 2</td>
<td>23</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">697</td>
<td>Harry Potter and the Goblet of Fire</td>
<td>19</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">698</td>
<td>Harry Potter and the Half-Blood Prince</td>
<td>19</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">699</td>
<td>Harry Potter and the Order of the Phoenix</td>
<td>24</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">700</td>
<td>Harry Potter and the Philosopher's Stone</td>
<td>63</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">701</td>
<td>Harry Potter and the Prisoner of Azkaban</td>
<td>26</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1241</td>
<td>Performance</td>
<td>7</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1839</td>
<td>The Magic Touch of Harry Potter</td>
<td>10</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">2050</td>
<td>The Wonderful World of Disney: Magical Holiday...</td>
<td>11</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2101</td>
<td>Tony Awards</td>
<td>6</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<ul>
<li>We can see that there are 16 movies and TV shows that have more than 5 shared actors with Harry Potter and the Philosopher’s Stone.</li>
<li>We would reccomend these movies to people who enjoy Harry Potter and the Philosopher’s Stone because the actors are very similar (more than 5 matches).</li>
<li>We will now use the recommend_barplot() function to visualize the data presented above.</li>
</ul>
<div id="d0f50dd2" class="cell" data-execution_count="98">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>recommend_barplot(df <span class="op">=</span> recommendations1, </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>                  movie <span class="op">=</span> <span class="st">"Harry Potter and the Philosopher's Stone"</span>, </span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                  min_num_shared_actors <span class="op">=</span> <span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="HW2_files/figure-html/cell-16-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>From the bar plot above, we can see that the movies or TV shows that share the most actors with Harry Potter and the Philosopher’s Stone are “Harry Potter and the Chamber of Secrets” and “Creating the World of Harry Potter.” This makes sense because all of the Harry Potter movies share many actors.</li>
</ul>
</section>
<section id="recommendations-for-good-will-hunting" class="level2">
<h2 class="anchored" data-anchor-id="recommendations-for-good-will-hunting">Recommendations for Good Will Hunting</h2>
<ul>
<li>Using the results2.csv dataframe imported above, I will create a dataframe with two columns “movie or TV name” and “number of shared actors” using the recommend_dataframe() function.</li>
</ul>
<div id="1a653f68" class="cell" data-execution_count="99">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>recommendations2 <span class="op">=</span> recommend_dataframe(results2)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>recommendations2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="99">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">movie or TV name</th>
<th data-quarto-table-cell-role="th">number of shared actors</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>'Saving Private Ryan': Boot Camp</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>...First Do No Harm</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>10-8: Officers on Duty</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>11 Colours of the Bird</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>12 Dates of Christmas</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1275</td>
<td>Zerophilia</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1276</td>
<td>eXistenZ</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1277</td>
<td>mid90s</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1278</td>
<td>Åke and His World</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1279</td>
<td>알아두면 쓸데없는 지구별 잡학사전</td>
<td>1</td>
</tr>
</tbody>
</table>

<p>1280 rows × 2 columns</p>
</div>
</div>
</div>
<ul>
<li>We can again see that our function works in creating the dataframe with the two desired columns.</li>
<li>We will now sort by movies or tv shows that have more than 3 shared actors with Good Will Hunting.</li>
</ul>
<div id="41c1f5db" class="cell" data-execution_count="100">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>recommendations2.loc[recommendations2[<span class="st">"number of shared actors"</span>] <span class="op">&gt;</span> <span class="dv">3</span>,:]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="100">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">movie or TV name</th>
<th data-quarto-table-cell-role="th">number of shared actors</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">285</td>
<td>Due South</td>
<td>6</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">316</td>
<td>FX: The Series</td>
<td>4</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">394</td>
<td>Good Will Hunting</td>
<td>49</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">512</td>
<td>Jimmy Kimmel Live!</td>
<td>4</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">541</td>
<td>LIVE with Kelly and Mark</td>
<td>4</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">606</td>
<td>Mayday</td>
<td>5</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">803</td>
<td>Saturday Night Live</td>
<td>5</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">812</td>
<td>School Ties</td>
<td>4</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">885</td>
<td>Sue Thomas: F.B.Eye</td>
<td>4</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">888</td>
<td>Suits</td>
<td>4</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1003</td>
<td>The Graham Norton Show</td>
<td>4</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1071</td>
<td>The Oscars</td>
<td>4</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1131</td>
<td>The Tonight Show with Jay Leno</td>
<td>4</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1140</td>
<td>The View</td>
<td>4</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1228</td>
<td>War of the Worlds</td>
<td>4</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<ul>
<li>We can see that there are 14 movies and TV shows that have more than 3 shared actors with Good Will Hunting.</li>
<li>I would reccomend these movies to people who enjoy Good Will Hunting because the actors are very similar (more than 3 matches).</li>
<li>We will now use the recommend_barplot() function to visualize the data presented above.</li>
</ul>
<div id="ae85ef8a" class="cell" data-execution_count="101">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>recommend_barplot(df <span class="op">=</span> recommendations2, </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>                  movie <span class="op">=</span> <span class="st">"Good Will Hunting"</span>, </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>                  min_num_shared_actors <span class="op">=</span> <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="HW2_files/figure-html/cell-19-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>From the bar plot above, we can see that the movies or TV shows that share the most actors with Good Will Hunting are “Due South”, “Mayday”, and “Saturday Night Live”. We would recommend these shows the most to Good Will Hunting fans.</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>